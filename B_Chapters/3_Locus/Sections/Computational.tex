\section{Computational and analytic methods}

\subsection{Pre-processing of Ig-Seq sequencing data}

Pre-processing of Illumina sequencing data from Ig-Seq libraries was performed primarily using pRESTO, a suite of tools for converting raw immunoglobulin sequencing reads into unique repertoire sequencing.

 % TODO: Specify where to look for more information on command functionality, and where to find scripts.

\subsubsection{Read quality control}

After rarefaction, the raw read set underwent quality control, discarding any read with an average Phred score of less than 20 (\texttt{FilterSeq quality}). The number of reads passing the filter was recorded for each sample.

The \texttt{pRESTO} command for the filtering operation is as follows:

\texttt{FilterSeq quality -q 20 -s <raw-reads-file>}

\subsubsection{Primer masking and UMI extraction}

Following quality filtering, the reads underwent primer masking, during which fixed primer sequences were identified and removed from each read (\texttt{MaskPrimers score --mode cut}). Starting from a specified start site, % describe primer masking algorithm from fixed start

In this case, the 5' reads (containing the UMI) were initially masked for the invariant M1s primer sequence 5' of the UMI region, while the sequence of the constant-region primer CC was removed from the 3' reads (see \Cref{app:oligos_tsa} for primer sequence details). The 5' reads then underwent a second round of masking, in which the first 16 bases of the read were extracted and recorded as that read's UMI, and the 3' invariant part of the TSA sequence (CTTGGGG) was removed. The \texttt{pRESTO} commands for these masking operations are as follows:

\texttt{MaskPrimers score --mode cut --start 0 -s <5prime-read-file> -p <M1s-primer-file>}
\texttt{MaskPrimers score --mode cut --start 0 -s <3prime-read-file> -p <CC-primer-file>}
\texttt{MaskPrimers score --mode cut --barcode --start 16 --maxerror [MAX ERROR HERE] -s <5primer-read-file-masked> -p <TSA-3prime-sequence-file>}

\subsubsection{Barcode error handling}

The use of UMI sequences enables biases and errors in library insert sequences to be corrected by taking the consensus sequence of all reads sharing a given UMI (a molecular identifier group, or MIG). However, PCR and sequencing errors can also affect the sequence of the UMI itself, in which case reads that in fact belong to a single MIG will be spuriously separated during pre-processing; this can result in spuriously low MIG read counts, spuriously high numbers of unique sequences, and avoidable loss of sequencing data due to reads with erroneous barcodes being discarded (as low-quality, low-read-count unique sequences) at various points in the pre-processing pipeline.

In addition to these barcode errors, barcode collisions can occur, in which multiple distinct sequences are labelled with the same UMI sequence and spuriously grouped together during UMI grouping. This can lead to spuriously large MIGs and spuriously low numbers of unique sequences, and in extreme cases lead to the rejection and loss of entire MIGs due to an insufficiently high level of sequence identity during consensus generation (see below). 

The level of barcode errors in a dataset can be reduced by clustering reads with highly similar barcodes together before consensus read generation, while barcode collisions can be reduced by splitting sequences within an MIG that differ in sequence by more than a threshold amount. In \texttt{pRESTO}, these error handling steps are achieved by %describe clustering and splitting steps in pRESTO pipeline

The \texttt{pRESTO} commands used to perform these operations are as follows; the third command concatenates the cluster annotations from the first two to label each read with a single cluster assignment, while the fourth copies cluster and barcode annotations from the 5' reads to their 3' pairs and discards reads whose pair was dropped during quality filtering or subsequent processing steps:

\texttt{ClusterSets barcode -f BARCODE -k CLUSTER --cluster cd-hit-est --prefix B --ident [IDENT PARAM HERE] -s <umi-tagged-5prime-reads>}
\texttt{ClusterSets set -f CLUSTER -k CLUSTER --cluster vsearch --prefix S --ident [IDENT PARAM HERE] -s <barcode-clustered-5prime-reads>}
\texttt{ParseHearders collapse -f CLUSTER --act cat -s <split-clustered-5prime-reads>}
\texttt{PairSeq -1 <cluster-collapsed-5prime-reads> -2 <masked-3prime-reads> --1f BARCODE CLUSTER --coord illumina}

\subsubsection{Consensus-read generation}

Following the clustering and unification steps described in the previous subsection, the 5' and 3' reads files underwent UMI aggregation and consensus building. In this process... % describe algorithm for BuildConsensus

The output of consensus-read aggregation is a FASTQ file containing a single consensus entry for each cluster annotation, labelled with its CONSCOUNT (the number of reads contributing to that consensus sequence) and the number of reads allocated to each barcode in the cluster. This file is typically much smaller than the preceding, uncollapsed reads files, enabling subsequent steps in the analysis to be performed substantially more quickly.

The \texttt{pRESTO} commands for consensus-read generation are as follows; as before, \texttt{PairSeq} is used to unify the two sequence files by dropping consensus sequences for which no pair is present with that cluster assignment:

\texttt{BuildConsensus --bf CLUSTER --bf CLUSTER BARCODE --act set set --maxerror [ERROR PARAM HERE] --maxgap [GAP PARAM HERE] -s <post-pairseq-reads-file>}
\texttt{PairSeq -1 <5prime-reads-consensus> -2 <3prime-reads-consensus> --coord presto}

\subsubsection{Merging paired consensus reads into a single IgH sequence}

After consensus-read generation, the next step in the pre-processing pipeline is to merge paired forward and reverse consensus reads into a single contiguous variable-region sequence. 

...The reverse sequence is reverse-complemented and an overlapping alignment between the two sequences is found using \texttt{blastn}... % Describe sequential algorithm

The cluster, barcode and CONSCOUNT annotations, which were unified between paired sequences at the end of the previous step, are copied from the forward read to the new merged sequence.

\texttt{AssemblePairs sequentian --coord presto --aligner blastn --scanrev --rc tail --1f CONSCOUNT~CLUSTER~BARCODE~BARCODE\_COUNT -1 <forward-sequence-file> -2 <reverse-sequence-file> -r <V-segment-file>}

\subsubsection{Collapsing identical sequences and}

Each consensus sequence in the data set is now expected to represent a unique RNA molecule in the original sample. To group and quantify the abundance of each sequence present in the sample, consensus sequences with identical insert sequences are now collapsed together. 

During this collapsing process, the number of instances of each unique sequences are counted and added to the sequence file as a new DUPCOUNT annotation. In addition, the cluster, barcode and CONSCOUNT annotations from the collapsed sequences are copied to the new unique entry, with the new cluster and barcode lists being the union of the contributing entries and the new CONSCOUNT being the sum. The DUPCOUNT annotation of each new unique sequence is therefore equal to the number of entries in its CLUSTER annotation.

\texttt{CollapseSeq --inner --cf CONSCOUNT CLUSTER BARCODE BARCODE\_COUNT --act sum set set set -n [GAP PARAM HERE] -s <merged-pair-file>}

% TODO: Describe role of --inner and gap parameter

\subsubsection{Removing singleton sequences and conversion to FASTA}

In the final step in the pRESTO pre-processing pipeline, unique sequences with a CONSCOUNT of no greater than 1 (i.e. sequences represented by only one barcode with only one associated read) are discarded from the data set; these sequences, which were unable to undergo UMI-associated read correction, cannot be considered reliable and are excluded from downstream analysis. % Unfortunately, this will also exclude many genuine, but rare, sequences

% TODO: Add stuff about grouping by replicate where appropriate

The \texttt{pRESTO} command for separating singletons (i.e. entries with a CONSCOUNT annotation of less than 2) from non-singletons is as follows:

\texttt{SplitSeq.py group -f CONSCOUNT --num 2 -s <collapsed-sequence-file>}

After separating singletons, the remaining sequences are converted from FASTQ to FASTA format for downstream processing using \texttt{seqtk seq -a}.

\subsubsection{V/D/J identity assignment}